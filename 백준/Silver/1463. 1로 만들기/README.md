# [Silver III] 1로 만들기 - 1463 

[문제 링크](https://www.acmicpc.net/problem/1463) 

### 과정
DP의 계산 구조를 설명할 때는 대부분의 예제가 [N] + [N-1], [N] + [N-1] + [N-2] ... 로 나아가곤 한다.
그래서 이 문제를 풀 때도 N부터 N-1 , N-1-1... 순으로 구해야 한다고 생각했다.
그러나 이미 해가 다 구해져 있는 문제를 설명할 때는 역으로 계산하는 것이 가능하지만
이런 문제를 풀 때에는 1부터 N까지 도달해야 시작해야 한다.

당연한 원리이지만 DP문제를 처음 접하면서 깨닫기까지 오래 걸렸다...!


DP의 핵심 아이디어는 최적 부분 구조 와 중복 부분 문제를 활용하는 것이다. 

**작은 부분 문제의 최적해를 활용해서 큰 문제의 최적해를 구하려고 한다**는 것을 잘 기억하자.

> 문제를 풀 때는 1부터 시작해야 한다!
----------------------------------------------------------------------------


### 코드 설명

```
const fs = require('fs');
const x = Number(require('fs').readFileSync('test.txt').toString().trim());

let dp = new Array(x+1).fill(0); //왜?

dp[2] = 1; //숫자 2와 3을 만드는 데 필요한 최소 연산의 횟수를 정의하는 것 
dp[3] = 1; //2와 3은 각각 1을 빼는 연산 한 번으로 1을 만들 수 있으므로 초기값으로 1을 설정
```

예를 들어, 숫자 1에서 출발해서 숫자 2를 만드는 데 필요한 연산은 1을 더하는 것.
따라서 2를 만드는데 필요한 최소 연산 횟수는 1이다.

마찬가지로, 숫자 1에서 출발해서 숫자 3을 만드는 데 필요한 연산은 2를 더하는 것이다.
따라서 3을 만드는데 필요한 최소 연산 횟수는 2이다.

```

dp.forEach((value,index)=>{
   
    if(index>3){
        let temp = [dp[index-1]];
        index%2 === 0?temp.push(dp[index/2]):0;
        index%3 === 0?temp.push(dp[index/3]):0;
```
 예를 들어, index가 4인 경우에는 4 / 2가 2이므로, dp[4]를 계산하기 위해 이전에 계산한 dp[2]의 값을 활용
 
 
```
        dp[index] = Math.min(...temp)+1;   
    }
})
console.log(dp[x])
```
temp에는 index에 도달하기까지의 가능한 모든 연산의 결과가 담겨있다 

ex) 9 => %3 , -1 가능 => dp[9/3] 와 dp[9-1]의 value를 temp에 담아두고,

(현재 index까지 오는 횟수) +1 을 한 뒤, 더 작은 값을 dp[9]에 담는다  




### 성능 요약

메모리: 21832 KB, 시간: 392 ms

### 분류

다이나믹 프로그래밍

### 문제 설명

<p>정수 X에 사용할 수 있는 연산은 다음과 같이 세 가지 이다.</p>

<ol>
	<li>X가 3으로 나누어 떨어지면, 3으로 나눈다.</li>
	<li>X가 2로 나누어 떨어지면, 2로 나눈다.</li>
	<li>1을 뺀다.</li>
</ol>

<p>정수 N이 주어졌을 때, 위와 같은 연산 세 개를 적절히 사용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 출력하시오.</p>

### 입력 

 <p>첫째 줄에 1보다 크거나 같고, 10<sup>6</sup>보다 작거나 같은 정수 N이 주어진다.</p>

### 출력 

 <p>첫째 줄에 연산을 하는 횟수의 최솟값을 출력한다.</p>



